		in_t.setToolTipText("Введите толщину материала");//всплывающая подсказка при наведении на текстовое поле
        		panel_1.add(calc_v);//Добавление кнопки на панель panel_1
		
		//Добавление компонентов JLabel, JTextField, JCheckBox на панель panel
		panel.add(label1);
		panel.add(in);
		panel.add(label2);
		panel.add(out);
		panel.add(label3);
		panel.add(in_a);
		panel.add(label4);
		panel.add(in_h);
		panel.add(label5);
		panel.add(in_l);	
		panel.add(label6);
		panel.add(in_t);	
		//Добавление компонентов JLabel, JTextField, JCheckBox на панель panel

		
		
		in.addItemListener(new ItemListener(){   /*Для компонента флажок устанавливаем слушатель события                                                        
			Если нажать на компонент - сработает проверка выбран флажок или снят */                                                     
			public void itemStateChanged(ItemEvent e) 
			/*. В теле метода itemStateChanged располагается код, который выполняется при смене состояния флажка. */
			{
				if (e.getSource()==in)//если событие произошло именно с флажком in, то выполняется следующее
					if(e.getStateChange()==1){ /* Если данный компонент флажок включен (==1), то это значит 
					что введены внутренние размеры */
						 int_in=1;//переменная отвечающая были ли введены внутренние размеры, 1-да, 0-нет
						 int_out=0;//переменная отвечающая были ли введены внешние размеры, 1-да, 0-нет
						 out.setSelected(false);//если флажок на внешних размер был включен - выключить его
						}
					else { //флажок выключен
						int_in=0;//переменная отвечающая были ли введены внутренние размеры, 1-да, 0-нет
					}
			}                                                       
    	   }); 	
	
		out.addItemListener(new ItemListener(){   /*Для компонента флажок устанавливаем слушатель события                                                        
			Если нажать на компонент - сработает проверка выбран флажок или снят */                                                     
			public void itemStateChanged(ItemEvent e) 
			/*. В теле метода itemStateChanged располагается код, который выполняется при смене состояния флажка. */
			{
				if (e.getSource()==out)//если событие произошло именно с флажком out, то выполняется следующее
					if(e.getStateChange()==1){ /* Если данный компонент флажок включен (==1), то это значит 
					что введены внешние размеры */
						 int_in=0;//переменная отвечающая были ли введены внутренние размеры, 1-да, 0-нет
						 int_out=1;//переменная отвечающая были ли введены внешние размеры, 1-да, 0-нет
						 in.setSelected(false);//если флажок на внешних размер был включен - выключить его
						}
					else { //флажок выключен
						int_out=0;//переменная отвечающая были ли введены внешние размеры, 1-да, 0-нет
					}
			}                                                       
    	   }); 
		
		calc_v.addActionListener(new ActionListener()   
    			/* 	out - кнопка Рассчитать объем
    	 		"."  - указывает к какой переменной (кнопке) следует применить слушателя.
    	 		addActionListener - добавление слушателя ActionListener к кнопке
    	  		new - Оператор new создает экземпляр указанного класса 
    	  		(Для того чтобы кнопки стали функциональными, каждой из них необходимо присвоить обработчик событий, 
    	  		который будет отвечать за реагирование на события. 
    	  		В нашем случае требуется идентифицировать событие нажатия кнопки – путем щелчка мышью. 
    	  		Поэтому будет использоваться интерфейс "ActionListener", 
    	  		предназначенный для обработки событий "ActionEvent".
    	  		тело интерфейса указывается ниже после фигурной скобки "{"
    	  		*/ 
    	   {                                                         
    	    public void actionPerformed(ActionEvent e)   
    	    /* 	ActionListener" имеет метод "actionPerformed" объекта "ActionEvent", 
      		который реализуется путем простого вызова обработчика событий ActionPerformed.
      		Ключевое слово public означает, что метод actionPerformed() доступен для любого другого класса Java
      		Ключевое слово void означает, что метод main() не возвращает данных в программу, которая его вызвала. 
      	*/
    	    {  
    	    	if ((int_in==0)&&(int_out==0)){ /*Если не выбран ни один флажок, выйдет ошибка что нужно 
    	    	выбрать внутренние или внешние размеры введены */
	    			JDialog D=new JDialog();
	    			JOptionPane.showMessageDialog(D, "Вы должны выбрать внутренние или внешние размеры "
	    					+ "введены", "Ошибка", JOptionPane.WARNING_MESSAGE);	
    	    	} else { //Если какой то из флажков выбран, то узнаем какой именно
    	    		
            	if ((isValidInput(in_a, "ширину")) && 
    	    		(isValidInput(in_h, "высоту")) && 
    	    		(isValidInput(in_l, "глубину"))&& 
    	    		(isValidInput(in_t, "толщину материала")))
    	    		/* if - оператор если. * isValidInput проверяет данные на правильность, т.е. 
    		 		если в текстовые поля введены буквы или символы (текст, который невозможно преобразовать в цифры).
    		   		Если введены некорректные данные, то выдает ошибку */	
    	    		{
            		
            		if (int_out==1){//введены внешние размеры
	            		if ((Double.parseDouble(in_a.getText())<=Double.parseDouble(in_t.getText())*2)||
	            			(Double.parseDouble(in_h.getText())<=Double.parseDouble(in_t.getText())*2)||
	            			(Double.parseDouble(in_l.getText())<=Double.parseDouble(in_t.getText())*2)){ 
		    	    			JDialog D=new JDialog();
		    	    			JOptionPane.showMessageDialog(D, "Внешние размеры не могут быть меньше толщины двух стенок", "Ошибка", JOptionPane.WARNING_MESSAGE);	
	        	    	} else {
		    	    		Volume.gettext(); /* Обращаемся в класс Volume к методу gettext 	*/
		    	    		frame.setVisible(false);//Окно становится невидимым
		    	    		Result.main(null);
		    	    		/* 	что будет происходить при нажатии на кнопку 
		    				(открывается новое окно с результатами) 
		    				программа передает в метод main класса Result null. 
		    				Тем самым происходит запуск метода без передачи переменных 
		    				*/
	        	    	}
            		} else { //введены внутренние размеры
            			Volume.gettext(); /* Обращаемся в класс Volume к методу gettext 	*/
	    	    		frame.setVisible(false);//Окно становится невидимым
	    	    		Result.main(null);
	    	    		/* 	что будет происходить при нажатии на кнопку 
	    				(открывается новое окно с результатами) 
	    				программа передает в метод main класса Result null. 
	    				Тем самым происходит запуск метода без передачи переменных 
	    				*/
            		}
    	    		}
    	    	} 
    	     }                                                        
    	   });  

	
	
	
	}
	
	//проверка данных, введенных пользователем
    public static boolean isValidInput(JTextField jtxt, String description) {

        JDialog D = new JDialog();
		//если был введен какой-либо текст
        if (jtxt.getText().trim().length() > 0) {
            //проверка на ввод только целого числа
            try { /* Для задания блока программного кода, который требуется защитить от исключений, используется ключевое слово try. 
				Сразу же после try-блока помещается блок catch, задающий тип исключения которое вы хотите обрабатывать.
				Исключение – это проблемная ситуация, возникающая по мере выполнения кода программы. Работает она так:
				1.Выполняется код внутри блока try. 2.Если в нём ошибок нет, то блок catch(err) игнорируется, то есть выполнение 
				доходит до конца try и потом прыгает через catch. 3.Если в нём возникнет ошибка, то выполнение try на ней
				 прерывается, и управление прыгает в начало блока catch(err).
				*/
              
                 double num = Double.parseDouble(jtxt.getText()); //попытка преобразовать текст в целое число      
                return true; //если все нормально - возвращаем true

            } catch (NumberFormatException e) {
            	/* Для задания блока программного кода, который требуется защитить от исключений, используется ключевое слово try. 
				Сразу же после try-блока помещается блок catch, задающий тип исключения которое вы хотите обрабатывать.
				Исключение – это проблемная ситуация, возникающая по мере выполнения кода программы. Работает она так:
				1.Выполняется код внутри блока try. 2.Если в нём ошибок нет, то блок catch(err) игнорируется, то есть выполнение 
				доходит до конца try и потом прыгает через catch. 3.Если в нём возникнет ошибка, то выполнение try на ней
				 прерывается, и управление прыгает в начало блока catch(err).
				*/

                //предупреждение - неверный формат числа
                JOptionPane.showMessageDialog(D, "Вы должны ввести целое число!", "Ошибка", JOptionPane.WARNING_MESSAGE);

                //расположить курсор в текстовое поле, чтобы пользователь еще раз ввел число
                jtxt.requestFocus();
                jtxt.setText("");//очистить текстовое поле

                return false;//ошибка - возвращаем false
            }

        } else {// если пользователь не ввели никаких данных

            //предупреждение, что нужно ввести данные
            JOptionPane.showMessageDialog(D, "Введите " + description, "Ошибка", JOptionPane.WARNING_MESSAGE);

            //расположить курсор в текстово окне, чтобы пользователь еще раз ввел число
            jtxt.requestFocus();
            jtxt.selectAll();//очистить текстовое поле

            //ошибка - возвращаем false
            return false;
        }
    }	

}
